# [Clean Architecture　達人に学ぶソフトウェアの構造と設計] 第3部 設計の原則

この部では、クリーンなコードを書くためにSOLID原則をアーキテクチャ的にどのような意味を持つのかを中心に、関数やデータ構造をどのようにクラスに組み込むのか、そしてクラスの相互接続をどのようにするのか説明してくれている。
「クラス」と言われると、OOPにしか通用しないように聞こえるがそうではなく、ここで言うクラスとは単にいくつかの機能やデータをまとめたものを指している。

SOLIDと言うフレーズは次の各原則の頭文字をなぞったものである(各原則の詳細については後ほど)。

```text
[S]ingle Responsibility Principle - 単一責任の原則
[O]pen Closed Principle           - オープン・クローズドの原則
[L]iskov Substitution Principle   - リスコフの置換原則
[I]nterface Segregation Principle - インターフェース分離の原則
[D]ependency Inversion Principle  - 依存関係逆転の原則
```

また、SOLID原則の目的は次のように要約されている。

> SOLID原則の目的は、次のような性質をもつモジュールレベルのソフトフェア構造を作ることである。
> ・変更に強いこと
> ・理解しやすいこと
> ・コンポーネントの基盤として、多くのソフトフェアシステムで利用できること

(正直これだけだど雰囲気はなんとなく分かる気がするけど、説明しろと言われたらできない程度の理解です。はい。)

最後に、SOLID原則を知るに当たり頭の片隅に留めて置くことは、優れてたシステムを構築するには、SOLID原則に沿ったモジュールレベル(中間レベル)のコンポーネントだけではなく、コンポーネントの原則と上位レベルのアーキテクチャの原則の知識も必要となるということ。
(これら2つの原則については、SOLID原則が終わってから紹介されるらしい)

## 第7章 単一責任の原則(Single Responsibility Principle)

単一責任の原則は次のように要約されている。

> モジュールはたったひとりのユーザーやステークホルダーに対して責務を負うべきである。

「たったひとり」というのは不適切なのだとか。というのも、複数のユーザーやステークホルダーがシステムを同じように変更したいと考えることもあるからだとか。
そこで、本書ではこれらの変更を望む人たちをひとまとめにしたグループとして扱い、このグループをアクターと呼んでいる。

そして、これを踏まえて先ほどの要約を訂正すると次のようになる。

> モジュールはたったひとつのアクターに対して責務を負うべきである。

個人的には前者の方がイメージを掴み安かった。(どうでも良いけど「イメージ」って他の言葉に置き換えると何がちょうど良いんだろ、雰囲気？大枠？こういう意味がふわふわした言葉って使う時にすごい便利に思えるんだけど、こういうふうに思うのは、何と無くの理解で済んで脳への負担が少ないからだったりすんのかな)
